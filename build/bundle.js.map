{"version":3,"sources":["webpack:///webpack/bootstrap 06a7564e364f8839f0e1","webpack:///./src/index.js","webpack:///./src/layoutGenerator.js","webpack:///./src/vec.js","webpack:///./src/mapNode.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;;;;;;AC1FA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,MAAK,GAAG,iBAAiB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oCAAmC;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;;;AAGA;AACA;;;;;;;ACvRA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 06a7564e364f8839f0e1\n **/","var layoutGenerator = require('./layoutGenerator.js');\r\n\r\n\r\nvar nodeGoal = 2000;\r\nvar iterCount = 30;\r\n\r\nvar w = window.innerWidth;\r\nvar h = window.innerHeight;\r\nvar sqrSize = Math.min(w, h);\r\n\r\nvar map = d3.select('#map-container')\r\n    .append('canvas')\r\n        .attr('width', w)\r\n        .attr('height', h);\r\nvar sx = d3.scale.linear().domain([-3, 3]).range([0, sqrSize]);\r\nvar sy = d3.scale.linear().domain([-3, 3]).range([0, sqrSize]);\r\nvar ctx = map.node().getContext('2d');\r\n\r\nvar city = layoutGenerator();\r\n\r\nvar step = 0;\r\n(function animate() {\r\n    var start = Date.now();\r\n    var state = city.generate().state;\r\n\r\n    var rangeX = d3.extent(state.streets.nodes.map(node => node.pos[0]));\r\n    var rangeY = d3.extent(state.streets.nodes.map(node => node.pos[0]));\r\n    var rangeU = d3.extent(rangeX.concat(rangeY));\r\n    sx.domain(rangeU);\r\n    sy.domain(rangeU);\r\n\r\n    console.log();\r\n    console.log(Date.now() - start, 'ms per step', step);\r\n\r\n    ctx.clearRect(0, 0, w, h);\r\n    drawCanvas(state.streets.edges, ctx);\r\n    drawCanvasDistr(state.districts, ctx, state.streets.nodes);\r\n\r\n    if (state.streets.nodes.length < nodeGoal && step++ < iterCount)\r\n        window.requestAnimationFrame(animate);\r\n}());\r\n\r\nfunction drawCanvas(streets, ctx) {\r\n    console.log(streets.length, 'streets');\r\n    streets.forEach(function(edge) {\r\n        ctx.beginPath();\r\n        if (edge.forw.free && edge.back.free)\r\n            ctx.strokeStyle = 'black';\r\n        else if (edge.forw.free || edge.back.free)\r\n            ctx.strokeStyle = 'green';\r\n        else\r\n            ctx.strokeStyle = 'red';\r\n        ctx.moveTo(sx(edge.from.pos[0]), sy(edge.from.pos[1]));\r\n        ctx.lineTo(sx(edge.to.pos[0]), sy(edge.to.pos[1]));\r\n        ctx.stroke();\r\n    });\r\n}\r\n\r\nfunction drawCanvasDistr(dists, ctx, nodes) {\r\n    // var debug = [];\r\n    dists.forEach(function(bord) {\r\n        // debug.push(bord.map(n => nodes.indexOf(n)).join(' '))\r\n        ctx.fillStyle = 'rgba(' + randi(0, 255) + ',' + randi(0, 255) + ',0,.8)';\r\n\r\n        ctx.beginPath();\r\n        ctx.moveTo(sx(bord[0].pos[0]), sy(bord[0].pos[1]));\r\n        bord.slice(1).forEach(function(node) {\r\n            ctx.lineTo(sx(node.pos[0]), sy(node.pos[1]));\r\n        });\r\n        ctx.closePath();\r\n        ctx.fill();\r\n    });\r\n    ctx.fillStyle = '#fff';\r\n\r\n    console.log(dists.length, 'districts');\r\n    // console.log(debug.sort().join('\\n'));\r\n}\r\n\r\nfunction drawSVG(streets, map) {\r\n    var join = map.selectAll('line.road').data(streets);\r\n    join.enter()\r\n        .append('line')\r\n        .attr('class', 'road')\r\n        .attr({\r\n            x1: edge => sx(edge.from.pos[0]),\r\n            y1: edge => sy(edge.from.pos[1]),\r\n            x2: edge => sx(edge.to.pos[0]),\r\n            y2: edge => sy(edge.to.pos[1])\r\n        });\r\n    join.exit().remove();\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","var vec = require('./vec.js');\r\nvar mapNode = require('./mapNode.js');\r\n\r\n\r\nvar swapArr2 = [0, 0];\r\n\r\nfunction aff(val, min, max) {\r\n    return min + val * (max - min);\r\n}\r\n\r\nfunction prng(min, max) {\r\n    return aff(1/3 * (Math.random() + Math.random() + Math.random()), min, max);\r\n}\r\n\r\nfunction randi(min, max) {\r\n    return Math.floor(aff(Math.random(), min, max));\r\n}\r\n\r\n\r\nfunction mapHalfEdge(edge, invert) {\r\n    if (!(this instanceof mapHalfEdge))\r\n        return new mapHalfEdge(edge, invert);\r\n\r\n    this.free = true;\r\n    this.invert = Boolean(invert);\r\n    this.source = invert? edge.to: edge.from;\r\n    this.target = invert? edge.from: edge.to;\r\n    this.dir = (!invert)? edge.getDir(): (edge.getDir() + Math.PI) % (2 * Math.PI);\r\n\r\n    edge[invert? 'back': 'forw'] = this;\r\n    this.source.halfEdges.push(this);\r\n}\r\n\r\nmapHalfEdge.prototype.next = function() {\r\n    var twin = this.twin;\r\n    var dir = this.twin.dir;\r\n    var bestMatch = this.target.halfEdges.reduce(function(best, halfEdge) {\r\n        if (halfEdge.free == false || halfEdge === twin)\r\n            return best;\r\n        var rot = halfEdge.dir - dir;\r\n        while (rot < 0) rot += Math.PI * 2; // FIXME why all the wild variation in angles?\r\n        if (rot < best.score) {\r\n            best.halfEdge = halfEdge;\r\n            best.score = rot;\r\n        }\r\n        return best;\r\n    }, { score: Infinity})\r\n    // console.log(bestMatch.score)\r\n    return bestMatch.halfEdge;\r\n};\r\n\r\nmapHalfEdge.prototype.setSource = function (into) {\r\n    var old = this.source;\r\n    old.halfEdges.splice(old.halfEdges.indexOf(this), 1);\r\n    this.source = into;\r\n    into.halfEdges.push(this);\r\n    return this;\r\n};\r\n\r\n\r\nfunction mapEdge(node1, node2) {\r\n    if (!(this instanceof mapEdge))\r\n        return new mapEdge(node1, node2);\r\n    this.from = node1;\r\n    this.to = node2;\r\n    this.selfVec = [0, 0];\r\n\r\n    var halfEdgeForw = mapHalfEdge(this);\r\n    var halfEdgeBack = mapHalfEdge(this, true);\r\n    halfEdgeForw.twin = halfEdgeBack;\r\n    halfEdgeBack.twin = halfEdgeForw;\r\n\r\n    this.recomputeVec();\r\n}\r\n\r\nmapEdge.prototype.offset = function(dir, len) {\r\n    this.to.pos[0] = this.from.pos[0] + Math.sin(dir) * len;\r\n    this.to.pos[1] = this.from.pos[1] + Math.cos(dir) * len;\r\n    this.recomputeVec();\r\n    return this;\r\n}\r\n\r\nmapEdge.prototype.intersects = function(edge2) {\r\n    // http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect\r\n    var p = this.from.pos;\r\n    var r = this.selfVec;\r\n    var s = edge2.selfVec;\r\n    var subqp = vec.sub(edge2.from.pos, p, swapArr2);\r\n    var crossrs = vec.cross(r, s);\r\n\r\n    if (crossrs == 0)\r\n        return false;\r\n    var u = vec.cross(subqp, r) / crossrs;\r\n    if (u <= 0 || u >= 1)\r\n        return false;\r\n    var t = vec.cross(subqp, s) / crossrs;\r\n    if (t <= 0 || t >= 1)\r\n        return false;\r\n    return vec.sum(p, vec.scalar(t, r));\r\n}\r\n\r\nmapEdge.prototype.crop = function(node) {\r\n    var temp = this.to;\r\n    this.to = node;\r\n\r\n    // update half-edges\r\n    this.forw.target = node;\r\n    this.back.setSource(node);\r\n\r\n    this.recomputeVec();\r\n\r\n    var rest = mapEdge(node, temp); // WATCH used to have recomuteVec\r\n    // rest.forw.free = this.forw.free;\r\n    // rest.back.free = this.back.free;\r\n\r\n    return rest;\r\n};\r\n\r\nmapEdge.prototype.adapt = function(edges, dir, edgePush, r) {\r\n    var newNode = this.to;\r\n\r\n    var conflictEdge = null;\r\n    edges.forEach(function(edge) {\r\n        var newPos = this.intersects(edge);\r\n        if (newPos) {\r\n            newNode.pos[0] = newPos[0];\r\n            newNode.pos[1] = newPos[1];\r\n            this.recomputeVec();\r\n            conflictEdge = edge;\r\n        }\r\n    }, this);\r\n\r\n    if (conflictEdge) {\r\n        if (!this.snapToEdge(conflictEdge, r)) {\r\n            edgePush(conflictEdge.crop(newNode));\r\n            newNode.pivots.push(dir);\r\n        }\r\n    } else {\r\n        newNode.pivots.push(dir, dir + .5 * Math.PI, dir - .5 * Math.PI);\r\n    }\r\n\r\n    return conflictEdge !== null;\r\n};\r\n\r\nmapEdge.prototype.snapToNode = function (node, r) {\r\n    if (vec.dist(this.to.pos, node.pos) < r) {\r\n        this.to = node;\r\n        this.recomputeVec();\r\n\r\n        // update half-edges\r\n        var dir = this.getDir();\r\n        this.forw.target = node;\r\n        this.forw.dir = dir;\r\n        this.back.setSource(node);\r\n        this.back.dir = (dir + Math.PI) % (2 * Math.PI);\r\n\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nmapEdge.prototype.snapToEdge = function(edge, r) {\r\n    return this.snapToNode(edge.to, r) || this.snapToNode(edge.from, r);\r\n};\r\n\r\nmapEdge.prototype.recomputeVec = function() {\r\n    vec.sub(this.to.pos, this.from.pos, this.selfVec);\r\n    var dir = this.getDir();\r\n    if (this.forw) this.forw.dir = dir\r\n    if (this.back) this.back.dir = (dir + Math.PI) % (2 * Math.PI);\r\n    return this;\r\n};\r\n\r\nmapEdge.prototype.getDir = function() {\r\n    var temp = (this.selfVec[1] > 0? 1: -1) * Math.acos(this.selfVec[0] / vec.norm(this.selfVec));\r\n    // FIXME why is edge length 0?\r\n    return isNaN(temp)? 0: temp;\r\n};\r\n\r\nmapEdge.prototype.eq = function(edge) {\r\n    return edge.from === this.from && edge.to === this.to;\r\n};\r\n\r\n\r\nfunction layoutGenerator() {\r\n    if (!(this instanceof layoutGenerator))\r\n        return new layoutGenerator();\r\n    var start = mapNode(0, 0);\r\n    start.pivots.push(0, Math.PI / 2, Math.PI, -Math.PI / 2);\r\n    this.state = {\r\n        streets: {\r\n            nodes: [start],\r\n            edges: []\r\n        },\r\n        districts: [],\r\n\r\n        spread: .3,\r\n        snapR: .4,\r\n        short: .5,\r\n        long: 1\r\n    };\r\n};\r\n\r\nlayoutGenerator.prototype.removeCycle = function (border) {\r\n    border.forEach(function (halfEdge) {\r\n        halfEdge.free = false;\r\n    });\r\n};\r\n\r\nlayoutGenerator.prototype.addEdge = function(edge) {\r\n    this.state.streets.edges.push(edge);\r\n    return this;\r\n}\r\n\r\nlayoutGenerator.prototype.cycleFromHalfEdge = function(halfEdge0) {\r\n    var depth = 0;\r\n    var halfEdge = halfEdge0;\r\n    var path = [halfEdge0];\r\n\r\n    while (depth < 100) {\r\n        halfEdge = halfEdge.next();\r\n\r\n        if (!halfEdge || halfEdge === path[path.length - 1].twin)\r\n            return false;\r\n\r\n        if (halfEdge === halfEdge0) {\r\n            this.removeCycle(path);\r\n            this.state.districts.push(path.map(halfEdge => halfEdge.target));\r\n            return true;\r\n        }\r\n\r\n        path.push(halfEdge);\r\n        depth++;\r\n    }\r\n    return false;\r\n};\r\n\r\nlayoutGenerator.prototype.cycleFrom = function(edge) {\r\n    this.cycleFromHalfEdge(edge.forw);\r\n    this.cycleFromHalfEdge(edge.back);\r\n};\r\n\r\nlayoutGenerator.prototype.generate = function(t) {\r\n    this.state.streets.nodes.filter(function(node) {\r\n        return node.pivots.length > 0;\r\n    }).forEach(function(node, i, a) {\r\n        var dir = node.pivot() + prng(-this.state.spread, this.state.spread);\r\n        var len = prng(this.state.short, this.state.long);\r\n\r\n        var newEdge = mapEdge(node, mapNode(0, 0))\r\n            .offset(dir, len);\r\n\r\n        var cropDown = newEdge.adapt(this.state.streets.edges, dir, this.addEdge.bind(this), this.state.snapR);\r\n        var cropUp = false;\r\n        if (!cropDown) {\r\n            cropUp = newEdge.offset(dir, 1.5 * len)\r\n                .adapt(this.state.streets.edges, dir, this.addEdge.bind(this), this.state.snapR);\r\n            if (!cropUp)\r\n                newEdge.offset(dir, len);\r\n        }\r\n\r\n        if (cropDown || cropUp) {\r\n            this.cycleFrom(newEdge);\r\n        }\r\n\r\n        if (!this.state.streets.edges.some(newEdge.eq, newEdge)) {\r\n            var resNode = newEdge.to;\r\n            if (this.state.streets.nodes.indexOf(resNode) === -1)\r\n                this.state.streets.nodes.push(resNode);\r\n\r\n            this.addEdge(newEdge);\r\n        }\r\n    }, this);\r\n\r\n    return this;\r\n};\r\n\r\n\r\nwindow.randi = randi;\r\nmodule.exports = layoutGenerator;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/layoutGenerator.js\n ** module id = 1\n ** module chunks = 0\n **/","function norm(a) {\r\n    return Math.sqrt(a[0] * a[0] + a[1] * a[1]);\r\n}\r\n\r\nfunction dot(a, b) {\r\n    return a[0] * b[0] + a[1] * b[1];\r\n}\r\n\r\nfunction cross(a, b) {\r\n    return a[0] * b[1] - a[1] * b[0];\r\n}\r\n\r\nfunction rescale(a, l) {\r\n    var na = norm(a);\r\n    return [\r\n        a[0] / na * l,\r\n        a[1] / na * l\r\n    ];\r\n}\r\n\r\nfunction scalar(n, x) {\r\n    return [n * x[0], n * x[1]];\r\n}\r\n\r\nfunction sum(a, b) {\r\n    return [a[0] + b[0], a[1] + b[1]];\r\n}\r\n\r\nfunction times(n, a) {\r\n    return [n * a[0], n * a[1]];\r\n}\r\n\r\nfunction sub(a, b, into) {\r\n    if (into) {\r\n        into[0] = a[0] - b[0];\r\n        into[1] = a[1] - b[1];\r\n        return into;\r\n    }\r\n    return [a[0] - b[0], a[1] - b[1]];\r\n}\r\n\r\nfunction dist (c1, c2) {\r\n    return Math.sqrt(Math.pow(c1[0] - c2[0], 2) + Math.pow(c1[1] - c2[1], 2))\r\n};\r\n\r\nvar vec = {\r\n    norm: norm,\r\n    dot: dot,\r\n    cross: cross,\r\n    rescale: rescale,\r\n    scalar: scalar,\r\n    sum: sum,\r\n    sub: sub,\r\n    dist: dist\r\n};\r\n\r\nmodule.exports = vec;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/vec.js\n ** module id = 2\n ** module chunks = 0\n **/","function mapNode(x, y) {\r\n    if (!(this instanceof mapNode))\r\n        return new mapNode(x, y);\r\n    this.pos = [x, y];\r\n    this.pivots = [];\r\n    this.halfEdges = [];\r\n    this.isActive = true;\r\n}\r\n\r\nmapNode.prototype.pivot = function () {\r\n    var pivotI = randi(this.pivots.length);\r\n    return this.pivots.splice(pivotI, 1)[0];\r\n};\r\n\r\nmodule.exports = mapNode;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/mapNode.js\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}